// Ocean Pixel Shader - Matches Terra's exact structure

@undefpiece( MaterialStructDecl )
@undefpiece( InstanceStructDecl )

@piece( DefaultOceanHeaderPS )
    @insertpiece( DefaultHeaderPS )
    @property( !hlms_shadowcaster )
        @insertpiece( OceanMaterialStructDecl )
        @insertpiece( OceanInstanceStructDecl )
    @else
        @insertpiece( DeclShadowCasterMacros )
        @property( hlms_shadowcaster_point || exponential_shadow_maps )
            @insertpiece( PassStructDecl )
        @end
    @end

    @property( !hlms_prepass && needs_view_dir )
        @insertpiece( DeclareBRDF )
        @insertpiece( DeclareBRDF_InstantRadiosity )
        @insertpiece( DeclareBRDF_AreaLightApprox )
    @end
@end

//-----------------------------------------------------------------------------
//		BODY CODE (Following Terra's exact pattern)
//-----------------------------------------------------------------------------

@piece( DefaultOceanBodyPS )
    @property( hlms_emulate_clip_distances && hlms_global_clip_planes && hlms_pso_clip_distances && syntax == glslvk)
        @foreach( hlms_pso_clip_distances, n )
            if( inPs.clipDistance@n < 0.0 )
                discard;
        @end
    @end

    // Ocean material reference
    #define oceanMaterial materialArray[0]
    
    @property( hlms_fine_light_mask || hlms_forwardplus_fine_light_mask )
        uint objLightMask = 0xFFFFFFFFu;
    @end
    
    @insertpiece( custom_ps_posMaterialLoad )
	
	PixelData pixelData;

    // ===== Sample ocean texture data =====
    float4 textureValue  = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv1.xy, inPs.uv1.z) );
    float4 textureValue2 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv2.xy, inPs.uv2.z) );
    float4 textureValue3 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv3.xy, inPs.uv3.z) );
    float4 textureValue4 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv4.xy, inPs.uv4.z) );

    textureValue = lerp(textureValue, textureValue2, inPs.blendWeight.x);
    textureValue = lerp(textureValue, textureValue3, inPs.blendWeight.y);
    textureValue = lerp(textureValue, textureValue4, inPs.blendWeight.z);
    
	// =====================================================
	// FOAM + WATER
	// =====================================================

	// Wave intensity
	// float waveIntensity = inPs.wavesIntensity;Â´
	// // Foam: GLSL curve
	// float foam = pow( saturate( textureValue.w ), 3.0f - waveIntensity ) * 0.45f * waveIntensity * waveIntensity;
	// // Roughness:fixed base + foam
	// float ROUGHNESS = 0.2f + foam;

	// // Water color: fake scattering via wave height
	// float4 diffuseCol;
	// diffuseCol.xyz = lerp( oceanMaterial.deepColour.xyz, oceanMaterial.shallowColour.xyz, inPs.waveHeight * waveIntensity );
	// // Additive foam
	// diffuseCol.xyz += foam;
	// diffuseCol.w = 1.0f;
	
	// ===== Wave calculations =====
    float waveIntensity = saturate( inPs.wavesIntensity );
    float waveFactor    = saturate( inPs.waveHeight ) * waveIntensity;
    
    // ===== Foam calculation =====
    float foam = pow( saturate( textureValue.w ), 2.0f ) * waveFactor * 0.5f;
    foam = saturate( foam );
    
    
	// float ROUGHNESS = lerp( 0.04f, 0.7f, foam );
	
	float ROUGHNESS = lerp( 0.01f, 0.5f, foam );
    
    // ===== Base water color =====
	float4 diffuseCol;
    diffuseCol.xyz = lerp( oceanMaterial.deepColour.xyz, oceanMaterial.shallowColour.xyz, waveFactor * 0.7f );
    float3 foamColour = float3( 0.82f, 0.86f, 0.9f );
    diffuseCol.xyz = lerp( diffuseCol.xyz, foamColour, foam );
    diffuseCol.w = 1.0f;

	// ===== Normal calculation =====

	// Normal from texture (baked waves)
	midf3 nNormal;
	nNormal.xy = textureValue.xy * 2.0f - 1.0f;
	nNormal.xy *= waveIntensity;
	nNormal.z  = _h( 1.0f );
	nNormal    = normalize( nNormal );

	// Flat ocean surface normal in VIEW space
	midf3 geomNormal = midf3_c( 0.0f, 1.0f, 0.0f );
	geomNormal = normalize( mul( geomNormal, toMidf3x3( passBuf.view ) ) );

	// View-space unit X axis (from view matrix)
	midf3 viewSpaceUnitX = midf3_c(
		passBuf.view[0].x,
		passBuf.view[1].x,
		passBuf.view[2].x
	);

	// Build stable TBN (NO derivatives!)
	midf3 tangent   = normalize( cross( geomNormal, viewSpaceUnitX ) );
	midf3 bitangent = cross( tangent, geomNormal );

	// Transform normal from texture into view space
	pixelData.normal = normalize(
		bitangent * nNormal.x +
		tangent   * nNormal.y +
		geomNormal * nNormal.z
	);

	@insertpiece( custom_ps_posSampleNormal )

	// Diffuse (water absorbs light)
	// pixelData.diffuse = midf4( diffuseCol * _h( 0.05f ) );
	
	// Option 1: Very dark water (still has some color absorption)
	pixelData.diffuse = midf4( diffuseCol * _h( 0.01f ) );

	// Option 2: Pure reflective water (no diffuse, only reflections)
	// pixelData.diffuse = midf4_c( 0.0f, 0.0f, 0.0f, 1.0f );

	// Specular (foam spreads highlights slightly)
	// float specAtten = lerp( 1.0f, 0.4f, foam );
	// pixelData.specular = midf3_c( specAtten, specAtten, specAtten );
	
	// Boost specular, only reduce for heavy foam
	float specAtten = lerp( 1.5f, 0.6f, foam );  // Boosted from 1.0->1.5, 0.4->0.6
	pixelData.specular = midf3_c( specAtten, specAtten, specAtten );

	// Fresnel - water (slightly higher than before for better reflections)
	pixelData.F0 = make_float_fresnel( 0.08f );

	// View
	pixelData.viewDir = normalize( -inPs.pos );
	pixelData.NdotV   = saturate( dot( pixelData.normal, pixelData.viewDir ) );

	// Roughness
	pixelData.perceptualRoughness = midf_c( ROUGHNESS );

	@property( perceptual_roughness )
		pixelData.roughness =
			max( pixelData.perceptualRoughness * pixelData.perceptualRoughness,
				 _h( 0.001f ) );
	@else
		pixelData.roughness =
			max( pixelData.perceptualRoughness, _h( 0.001f ) );
	@end

    
    // ===== Shadow maps =====
    @property( !hlms_use_prepass )
        @insertpiece( DoDirectionalShadowMaps )
    @end
    
    @property( hlms_use_prepass )
        rshort2 iFragCoord = rshort2( gl_FragCoord.x,
                                      @property( !hlms_forwardplus_flipY && syntax == glsl )passBuf.windowHeight.x - @end
                                      gl_FragCoord.y );
        
        @property( hlms_use_prepass_msaa )
            uint sampleMask = uint( gl_SampleMaskIn0 );
            float msaaDepth;
            uint subsampleDepthMask;
            float pixelDepthZ;
            float pixelDepthW;
            float2 pixelDepthZW;
            float pixelDepth;
            int intPixelDepth;
            int intMsaaDepth;
            int ulpError = int( lerp( 200.0, 5.0, gl_FragCoord.z ) );
            @foreach( hlms_use_prepass_msaa, n )
                pixelDepthZW = interpolateAtSample( inPs.zwDepth, @n );
                pixelDepthZ = pixelDepthZW.x;
                pixelDepthW = pixelDepthZW.y;
                pixelDepth = pixelDepthZ / pixelDepthW;
                msaaDepth = OGRE_Load2DMS( gBuf_depthTexture, iFragCoord.xy, @n ).x;
                intPixelDepth = floatBitsToInt( pixelDepth );
                intMsaaDepth = floatBitsToInt( msaaDepth );
                subsampleDepthMask = (abs( intPixelDepth - intMsaaDepth ) <= ulpError) ? 0xffffffffu : ~(1u << @nu);
                sampleMask &= subsampleDepthMask;
            @end
            
            sampleMask = sampleMask == 0u ? 1u : sampleMask;
            int gBufSubsample = int( findLSB( sampleMask ) );
            
            pixelData.normal = normalize( OGRE_Load2DMSF16( gBuf_normals, iFragCoord, gBufSubsample ).xyz * _h( 2.0 ) - _h( 1.0 ) );
            midf2 shadowRoughness = OGRE_Load2DMSF16( gBuf_shadowRoughness, iFragCoord, gBufSubsample ).xy;
        @else
            pixelData.normal = normalize( OGRE_Load2DF16( gBuf_normals, iFragCoord, 0 ).xyz * _h( 2.0 ) - _h( 1.0 ) );
            midf2 shadowRoughness = OGRE_Load2DF16( gBuf_shadowRoughness, iFragCoord, 0 ).xy;
        @end
        
        midf fShadow = shadowRoughness.x;
        
        @property( roughness_map )
            pixelData.roughness = shadowRoughness.y * 0.98 + 0.02;
        @end
    @end
    
    @property( !hlms_prepass )
        // ===== LIGHTING (PBS pieces handle everything) =====
        @insertpiece( LightingHeader )

        @insertpiece( custom_ps_preLights )

        @property( !custom_disable_directional_lights )
            @property( !(hlms_pssm_splits || (!hlms_pssm_splits && hlms_num_shadow_map_lights && hlms_lights_directional)) )
                midf fShadow = _h( 1.0f );
            @end

            @insertpiece( DoDirectionalLights )
        @end

        @insertpiece( DoPointLights )
        @insertpiece( DoSpotLights )

        @insertpiece( DoAreaApproxLights )
        @insertpiece( DoAreaLtcLights )

        @insertpiece( forward3dLighting )

        @property( needs_env_brdf && (use_envprobe_map || hlms_use_ssr || use_planar_reflections || vct_num_probes) )
            pixelData.envColourS = midf3_c( 0, 0, 0 );
            pixelData.envColourD = midf3_c( 0, 0, 0 );
        @end

        @insertpiece( applyVoxelConeTracing )

        @insertpiece( forwardPlusDoCubemaps )
        @insertpiece( applyIrradianceVolumes )

        @insertpiece( DoEmissiveLight )

        @property( use_envprobe_map )
            @property( use_parallax_correct_cubemaps && !hlms_enable_cubemaps_auto )
                @insertpiece( CubemapManualPcc )
            @end
            @property( !use_parallax_correct_cubemaps )
                @insertpiece( CubemapGlobal )
            @end
        @end

        @property( hlms_use_ssr )
            float4 ssrReflection = OGRE_Load2D( ssrTexture, iFragCoord, 0 ).xyzw;
            @property( use_envprobe_map )
                pixelData.envColourS = lerp( pixelData.envColourS.xyz, ssrReflection.xyz, ssrReflection.w );
            @else
                pixelData.envColourS += ssrReflection.xyz * ssrReflection.w;
            @end
        @end

        @insertpiece( DoPlanarReflectionsPS )

        @property( ambient_hemisphere )
            @property( use_envprobe_map || hlms_use_ssr || use_planar_reflections || vct_num_probes )
                @property( vct_num_probes )
                    if( vctSpecular.w == 0 )
                    {
                @end
                        // Reduce ambient contribution when we have reflections (50% less)
				pixelData.envColourS += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
											  midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWD );
											  // * _h( 0.5 );
				pixelData.envColourD += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
											  midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWS );
											  // * _h( 0.5 );
                @property( vct_num_probes )
                    }
                @end
            @else
                pixelData.envColourS = lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                            midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWD ) * _h( 0.5 );
                pixelData.envColourD = lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                            midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWS ) * _h( 0.5 );
            @end
        @end
        @property( ambient_fixed && vct_num_probes )
            finalColour += vctSpecular.w == 0 ? midf3_c( 0, 0, 0 ) :
                                                (midf3_c( passBuf.ambientUpperHemi.xyz ) * pixelData.diffuse.xyz);
        @end

        @property( needs_env_brdf )
            @insertpiece( BRDF_EnvMap )
        @end

        @property( hlms_fog )
            const float distToCamera = length( inPs.pos.xyz );
            const midf luminance = dot( finalColour.xyz,
                                       midf3_c( _h( 0.212655 ), _h( 0.715158 ), _h( 0.072187 ) ) );
            const midf lumFogWeight = max( exp2( atmoSettings.fogBreakFalloff * luminance +
                                                atmoSettings.fogBreakMinBrightness ),
                                          _h( 0.0 ) );
            midf fogWeight = midf_c( exp2( -distToCamera * atmoSettings.fogDensity ) );
            fogWeight = lerp( _h( 1.0 ), fogWeight, lumFogWeight );
            finalColour.xyz = lerp( inPs.fog.xyz, finalColour.xyz, fogWeight );
        @end
    @end ///!hlms_prepass

    // ===== OUTPUT =====
    @property( !hlms_render_depth_only )
        @property( !hlms_prepass )
            @property( !hw_gamma_write )
                outPs_colour0.xyz = sqrt( finalColour );
            @else
                outPs_colour0.xyz = finalColour;
            @end

            @property( hlms_alphablend )
                outPs_colour0.w = _h( 1.0 );
            @else
                outPs_colour0.w = _h( 1.0 );
            @end

            @property( debug_pssm_splits )
                outPs_colour0.xyz = lerp( outPs_colour0.xyz, debugPssmSplit.xyz, _h( 0.2f ) );
            @end

            @property( hlms_gen_normals_gbuffer )
                outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
            @end
        @else
            outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
            @property( hlms_pssm_splits )
                outPs_shadowRoughness = midf2_c( fShadow, (pixelData.roughness - 0.02) * 1.02040816 );
            @end
            @property( !hlms_pssm_splits )
                outPs_shadowRoughness = midf2_c( 1.0, (pixelData.roughness - 0.02) * 1.02040816 );
            @end
        @end
    @end
@end