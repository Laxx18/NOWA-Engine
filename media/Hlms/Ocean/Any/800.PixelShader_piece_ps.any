// Ocean header for PS - Exact Terra pattern

// CRITICAL: Undefine PBS pieces BEFORE DefaultHeaderPS tries to use them
@undefpiece( MaterialStructDecl )
@undefpiece( InstanceStructDecl )

@piece( DefaultOceanHeaderPS )
    @insertpiece( DefaultHeaderPS )
    @property( !hlms_shadowcaster )
        @insertpiece( OceanMaterialStructDecl )
        @insertpiece( OceanInstanceStructDecl )
    @else
        @insertpiece( DeclShadowCasterMacros )
        @property( hlms_shadowcaster_point || exponential_shadow_maps )
            @insertpiece( PassStructDecl )
        @end
    @end

    @property( !hlms_prepass && needs_view_dir )
        @insertpiece( DeclareBRDF )
        @insertpiece( DeclareBRDF_InstantRadiosity )
        @insertpiece( DeclareBRDF_AreaLightApprox )
    @end
@end

//-----------------------------------------------------------------------------
//		BODY CODE (Following Terra's exact pattern)
//-----------------------------------------------------------------------------

@piece( DefaultOceanBodyPS )
    PixelData pixelData;

    @property( hlms_emulate_clip_distances && hlms_global_clip_planes && hlms_pso_clip_distances && syntax == glslvk)
        @foreach( hlms_pso_clip_distances, n )
            if( inPs.clipDistance@n < 0.0 )
                discard;
        @end
    @end

    // Ocean material reference
    #define oceanMaterial materialArray[0]
    
    @property( hlms_fine_light_mask || hlms_forwardplus_fine_light_mask )
        uint objLightMask = 0xFFFFFFFFu;
    @end
    
    @insertpiece( custom_ps_posMaterialLoad )

    // ===== Sample ocean texture data =====
    float4 textureValue  = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv1.xy, inPs.uv1.z) );
    float4 textureValue2 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv2.xy, inPs.uv2.z) );
    float4 textureValue3 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv3.xy, inPs.uv3.z) );
    float4 textureValue4 = OGRE_SampleF16( terrainData, terrainDataSampler, float3(inPs.uv4.xy, inPs.uv4.z) );

    textureValue = lerp(textureValue, textureValue2, inPs.blendWeight.x);
    textureValue = lerp(textureValue, textureValue3, inPs.blendWeight.y);
    textureValue = lerp(textureValue, textureValue4, inPs.blendWeight.z);
    
    // ===== Wave calculations =====
    float waveIntensity = saturate( inPs.wavesIntensity );
    float waveFactor    = saturate( inPs.waveHeight ) * waveIntensity;
    
    // ===== Foam calculation =====
    float foam = pow( saturate( textureValue.w ), 2.0f ) * waveFactor * 0.5f;
    foam = saturate( foam );
    
    float ROUGHNESS = lerp( 0.02f, 0.3f, foam );
    
    // ===== Base water color (diffuse) =====
    float4 diffuseCol;
    diffuseCol.xyz = lerp( oceanMaterial.deepColour.xyz, oceanMaterial.shallowColour.xyz, waveFactor * 0.7f );
	
	float waterAlpha = lerp( oceanMaterial.deepColour.w, 0.3f, waveFactor * 0.7f );
	
    float3 foamColour = float3( 0.9f, 0.9f, 0.9f );
    diffuseCol.xyz = lerp( diffuseCol.xyz, foamColour, foam );
	diffuseCol.w = lerp( waterAlpha, 1.0f, foam );

    // ===== Normal from wave texture =====
    midf3 normalTS = midf3_c( textureValue.xyz * 2.0 - 1.0 );
    
    @property( !hlms_use_prepass )
        // Build TBN matrix (similar to Terra)
        midf3 geomNormal = normalize( midf3_c( inPs.normal ) );
        midf3 viewSpaceUnitX = mul( midf3_c( 1, 0, 0 ), toMidf3x3( passBuf.view ) );
        midf3 vTangent = normalize( cross( geomNormal, viewSpaceUnitX ) );
        midf3 vBinormal = cross( vTangent, geomNormal );
        midf3x3 TBN = buildMidf3x3( vBinormal, vTangent, geomNormal );
        
        pixelData.normal = normalize( mul( TBN, normalTS ) );
    @end
    
    @insertpiece( custom_ps_posSampleNormal )
    
    // ===== Populate pixelData BEFORE lighting =====
    pixelData.diffuse = midf4_c( diffuseCol );
    pixelData.specular = midf3_c( 1.0f, 1.0f, 1.0f ); // Water is highly specular
    
    // Metalness for water (non-metallic)
    midf metalness = _h( 0.0 );
    pixelData.F0 = lerp( midf3_c( 0.02f, 0.02f, 0.02f ), pixelData.diffuse.xyz * _h( 3.14159f ), metalness );
    pixelData.diffuse.xyz = pixelData.diffuse.xyz - pixelData.diffuse.xyz * metalness;
    
    pixelData.perceptualRoughness = midf_c( ROUGHNESS );
    @property( perceptual_roughness )
        pixelData.roughness = max( pixelData.perceptualRoughness * pixelData.perceptualRoughness, _h( 0.001f ) );
    @else
        pixelData.roughness = max( pixelData.perceptualRoughness, _h( 0.001f ) );
    @end
    
    @property( !hlms_use_prepass )
        @insertpiece( DoDirectionalShadowMaps )
    @end
    
    @property( hlms_use_prepass )
        // Use prepass data
        rshort2 iFragCoord = rshort2( gl_FragCoord.x,
                                      @property( !hlms_forwardplus_flipY && syntax == glsl )passBuf.windowHeight.x - @end
                                      gl_FragCoord.y );
        
        @property( hlms_use_prepass_msaa )
            uint sampleMask = uint( gl_SampleMaskIn0 );
            float msaaDepth;
            uint subsampleDepthMask;
            float pixelDepthZ;
            float pixelDepthW;
            float2 pixelDepthZW;
            float pixelDepth;
            int intPixelDepth;
            int intMsaaDepth;
            int ulpError = int( lerp( 200.0, 5.0, gl_FragCoord.z ) );
            @foreach( hlms_use_prepass_msaa, n )
                pixelDepthZW = interpolateAtSample( inPs.zwDepth, @n );
                pixelDepthZ = pixelDepthZW.x;
                pixelDepthW = pixelDepthZW.y;
                pixelDepth = pixelDepthZ / pixelDepthW;
                msaaDepth = OGRE_Load2DMS( gBuf_depthTexture, iFragCoord.xy, @n ).x;
                intPixelDepth = floatBitsToInt( pixelDepth );
                intMsaaDepth = floatBitsToInt( msaaDepth );
                subsampleDepthMask = (abs( intPixelDepth - intMsaaDepth ) <= ulpError) ? 0xffffffffu : ~(1u << @nu);
                sampleMask &= subsampleDepthMask;
            @end
            
            sampleMask = sampleMask == 0u ? 1u : sampleMask;
            int gBufSubsample = int( findLSB( sampleMask ) );
            
            pixelData.normal = normalize( OGRE_Load2DMSF16( gBuf_normals, iFragCoord, gBufSubsample ).xyz * _h( 2.0 ) - _h( 1.0 ) );
            midf2 shadowRoughness = OGRE_Load2DMSF16( gBuf_shadowRoughness, iFragCoord, gBufSubsample ).xy;
        @else
            pixelData.normal = normalize( OGRE_Load2DF16( gBuf_normals, iFragCoord, 0 ).xyz * _h( 2.0 ) - _h( 1.0 ) );
            midf2 shadowRoughness = OGRE_Load2DF16( gBuf_shadowRoughness, iFragCoord, 0 ).xy;
        @end
        
        midf fShadow = shadowRoughness.x;
        
        @property( roughness_map )
            pixelData.roughness = shadowRoughness.y * 0.98 + 0.02;
        @end
    @end
    
    @property( !hlms_prepass )
        // ===== Lighting Header =====
        @insertpiece( LightingHeader )

        @insertpiece( custom_ps_preLights )

        @property( !custom_disable_directional_lights )
            @property( !(hlms_pssm_splits || (!hlms_pssm_splits && hlms_num_shadow_map_lights && hlms_lights_directional)) )
                midf fShadow = _h( 1.0f );
            @end

            @insertpiece( DoDirectionalLights )
        @end

        // ===== POINT LIGHTS =====
        @insertpiece( DoPointLights )
        
        // ===== SPOT LIGHTS =====
        @insertpiece( DoSpotLights )

        // ===== AREA LIGHTS =====
        @insertpiece( DoAreaApproxLights )
        @insertpiece( DoAreaLtcLights )

        // ===== FORWARD+ LIGHTING =====
        @insertpiece( forward3dLighting )

        // ===== ENVIRONMENT LIGHTING =====
        @property( needs_env_brdf && (use_envprobe_map || hlms_use_ssr || use_planar_reflections || vct_num_probes) )
            pixelData.envColourS = midf3_c( 0, 0, 0 );
            pixelData.envColourD = midf3_c( 0, 0, 0 );
        @end

        // Voxel Cone Tracing
        @insertpiece( applyVoxelConeTracing )

        // Cubemaps
        @insertpiece( forwardPlusDoCubemaps )
        
        // Irradiance volumes
        @insertpiece( applyIrradianceVolumes )

        // Emissive (if needed for bioluminescence)
        @insertpiece( DoEmissiveLight )

        // ===== Environment Probe =====
        @property( use_envprobe_map )
            @property( use_parallax_correct_cubemaps && !hlms_enable_cubemaps_auto )
                @insertpiece( CubemapManualPcc )
            @end
            @property( !use_parallax_correct_cubemaps )
                @insertpiece( CubemapGlobal )
            @end
        @end

        // ===== Screen Space Reflections =====
        @property( hlms_use_ssr )
            float4 ssrReflection = OGRE_Load2D( ssrTexture, iFragCoord, 0 ).xyzw;
            @property( use_envprobe_map )
                pixelData.envColourS = lerp( pixelData.envColourS.xyz, ssrReflection.xyz, ssrReflection.w );
            @else
                pixelData.envColourS += ssrReflection.xyz * ssrReflection.w;
            @end
        @end

        // ===== PLANAR REFLECTIONS (CRITICAL FOR WATER!) =====
        @insertpiece( DoPlanarReflectionsPS )

        // ===== AMBIENT LIGHTING =====
        @property( ambient_hemisphere )
            @property( use_envprobe_map || hlms_use_ssr || use_planar_reflections || vct_num_probes )
                @property( vct_num_probes )
                    if( vctSpecular.w == 0 )
                    {
                @end
                        pixelData.envColourS += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                                      midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWD );
                        pixelData.envColourD += lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                                      midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWS );
                @property( vct_num_probes )
                    }
                @end
            @else
                pixelData.envColourS = lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                            midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWD );
                pixelData.envColourD = lerp( midf3_c( passBuf.ambientLowerHemi.xyz ),
                                            midf3_c( passBuf.ambientUpperHemi.xyz ), ambientWS );
            @end
        @end
        
        @property( ambient_fixed && vct_num_probes )
            finalColour += vctSpecular.w == 0 ? midf3_c( 0, 0, 0 ) :
                                                (midf3_c( passBuf.ambientUpperHemi.xyz ) * pixelData.diffuse.xyz);
        @end

        // ===== APPLY ENVIRONMENT BRDF =====
        @property( needs_env_brdf )
            @insertpiece( BRDF_EnvMap )
        @end

        // ===== FOG =====
        @property( hlms_fog )
            const float distToCamera = length( inPs.pos.xyz );
            const midf luminance = dot( finalColour.xyz,
                                       midf3_c( _h( 0.212655 ), _h( 0.715158 ), _h( 0.072187 ) ) );
            const midf lumFogWeight = max( exp2( atmoSettings.fogBreakFalloff * luminance +
                                                atmoSettings.fogBreakMinBrightness ),
                                          _h( 0.0 ) );
            midf fogWeight = midf_c( exp2( -distToCamera * atmoSettings.fogDensity ) );
            fogWeight = lerp( _h( 1.0 ), fogWeight, lumFogWeight );
            finalColour.xyz = lerp( inPs.fog.xyz, finalColour.xyz, fogWeight );
        @end
    @end ///!hlms_prepass

    // ===== OUTPUT =====
    @property( !hlms_render_depth_only )
        @property( !hlms_prepass )
            @property( !hw_gamma_write )
                outPs_colour0.xyz = sqrt( finalColour );
            @else
                outPs_colour0.xyz = finalColour;
            @end
			
			// Use the calculated alpha
            outPs_colour0.w = diffuseCol.w;

            @property( debug_pssm_splits )
                outPs_colour0.xyz = lerp( outPs_colour0.xyz, debugPssmSplit.xyz, _h( 0.2f ) );
            @end

            @property( hlms_gen_normals_gbuffer )
                outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
            @end
        @else
            // Prepass output
            outPs_normals = midf4_c( pixelData.normal * _h( 0.5 ) + _h( 0.5 ), 1.0 );
            @property( hlms_pssm_splits )
                outPs_shadowRoughness = midf2_c( fShadow, (pixelData.roughness - 0.02) * 1.02040816 );
            @end
            @property( !hlms_pssm_splits )
                outPs_shadowRoughness = midf2_c( 1.0, (pixelData.roughness - 0.02) * 1.02040816 );
            @end
        @end
    @end
@end